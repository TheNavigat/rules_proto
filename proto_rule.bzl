load(
    "@bazel_skylib//lib:shell.bzl",
    "shell",
)
load("//:plugin.bzl", "ProtoPluginInfo")

ProtoRuleInfo = provider("Provider for a proto rule", fields = {
    "name": "The prefix name of the rule (e.g 'py')",
    "rule": "The rule struct",
})

def _proto_rule_impl(ctx):
    go_tool = ctx.toolchains["@io_bazel_rules_go//go:toolchain"].sdk.go
    script = ctx.actions.declare_file(ctx.label.name + ".bash")

    rule_json = ctx.actions.declare_file("%s.json" % ctx.attr.name)
    rule_bzl = ctx.actions.declare_file("%s.bzl" % ctx.attr.name)
    rule_workspace = ctx.actions.declare_file("%s.WORKSPACE" % ctx.attr.name)
    rule_build = ctx.actions.declare_file("%s.BUILD" % ctx.attr.name)
    rule_test = ctx.actions.declare_file("%s_test.go" % ctx.attr.name)

    rule = struct(
        name = ctx.attr.name,
        kind = ctx.attr.kind,
        package = ctx.label.package,
        skipDirectoriesMerge = ctx.attr.skip_directories_merge,
        plugins = [str(p.label) for p in ctx.attr.plugins],

        implementationFilename = rule_bzl.path,
        workspaceExampleFilename = rule_workspace.path,
        buildExampleFilename = rule_build.path,
        testFilename = rule_test.path,

        implementationTmpl = ctx.file.implementation_tmpl.path,
        workspaceExampleTmpl = ctx.file.workspace_example_tmpl.path,
        buildExampleTmpl = ctx.file.build_example_tmpl.path,
        testTmpl = ctx.file.test_tmpl.path,
    )

    ctx.actions.write(
        output = rule_json,
        content = rule.to_json(),
    )

    inputs = [
        rule_json,
        ctx.file.implementation_tmpl,
        ctx.file.build_example_tmpl,
        ctx.file.workspace_example_tmpl,
        ctx.file.test_tmpl,
    ]

    outputs = [
        rule_bzl,
        rule_build,
        rule_workspace,
        rule_test,
    ]

    args = [
        "--rule_json=%s" % rule_json.path,
    ]

    ctx.actions.run(
        mnemonic = "ProtoRuleGenerate",
        progress_message = "Generating %s rule" % ctx.attr.name,
        executable = ctx.file.rulegen,
        arguments = args,
        inputs = inputs,
        outputs = outputs,
    )
    
    substitutions = {
        "@@ARGS@@": shell.array_literal(args),
        "@@RULEGEN_LABEL@@": shell.quote(str(ctx.attr.rulegen.label)),
        "@@RULEGEN_SHORT_PATH@@": shell.quote(ctx.executable.rulegen.short_path),
        "@@GENERATED_MESSAGE@@": """
# Generated by {label}
# DO NOT EDIT
""".format(label = str(ctx.label)),
        "@@RUNNER_LABEL@@": shell.quote(str(ctx.label)),
        "@@GOTOOL@@": shell.quote(go_tool.path),
    }

    ctx.actions.expand_template(
        template = ctx.file._script,
        output = script,
        substitutions = substitutions,
        is_executable = True,
    )

    runfiles = ctx.runfiles(files = [
        ctx.executable.rulegen,
        go_tool,
    ] + ctx.files.data + inputs + outputs)

    return [
        ProtoRuleInfo(
            name = ctx.attr.name,
            rule = rule,
        ),
        DefaultInfo(
            files = depset(outputs),
            runfiles = runfiles,
            executable = script,
        ),
    ]

_proto_rule = rule(
    implementation = _proto_rule_impl,
    attrs = {
        "kind": attr.string(
            doc = "The kind of rule",
            values = ["proto", "grpc"],
        ),
        "implementation_tmpl": attr.label(
            doc = "The rule implementation template",
            default = str(Label("//proto:aspect.bzl.tmpl")),
            allow_single_file = True,
        ),
        "workspace_example_tmpl": attr.label(
            doc = "The rule workspace example template",
            default = str(Label("//proto:WORKSPACE.tmpl")),
            allow_single_file = True,
        ),
        "build_example_tmpl": attr.label(
            doc = "The rule build example template",
            default = str(Label("//proto:BUILD.tmpl")),
            allow_single_file = True,
        ),
        "test_tmpl": attr.label(
            doc = "The rule build test example template",
            default = str(Label("//proto:test.go.tmpl")),
            allow_single_file = True,
        ),
        "plugins": attr.label_list(
            doc = "List of default plugins to include in the generated rule",
            providers = [ProtoPluginInfo],
        ),
        "skip_directories_merge": attr.bool(
            doc = "If the generated rule shoul skip merging directories",
        ),
         "data": attr.label_list(allow_files = True),
        "_script": attr.label(
            doc = "The rulegen runner script",
            default = "//tools/rulegen:rulegen.bash.in",
            allow_single_file = True,
        ),
        "rulegen": attr.label(
            doc = "The rulegen generator tool",
            default = "//tools/rulegen",
            allow_single_file = True,
            executable = True,
            cfg = "host",
        ),
    },
    executable = True,
    toolchains = ["@io_bazel_rules_go//go:toolchain"],
)

def proto_rule(name, **kwargs):
    runner_name = name + "-runner"
    _proto_rule(
        name = runner_name,
        tags = ["manual"],
        **kwargs
    )
    native.sh_binary(
        name = name,
        srcs = [runner_name],
        tags = ["manual"],
    )