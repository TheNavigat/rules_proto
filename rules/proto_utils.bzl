# Common data and functions

_rust_keywords = [
    "as",
    "break",
    "const",
    "continue",
    "crate",
    "else",
    "enum",
    "extern",
    "false",
    "fn",
    "for",
    "if",
    "impl",
    "let",
    "loop",
    "match",
    "mod",
    "move",
    "mut",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "type",
    "unsafe",
    "use",
    "where",
    "while",
]

_objc_upper_segments = {
    "url": "URL",
    "http": "HTTP",
    "https": "HTTPS",
}

def capitalize(s):
    """Capitalize a string - only first letter

    Args:
      s (string): The input string to be capitalized.

    Returns:
      (string): The capitalized string.
    """
    return s[0:1].upper() + s[1:]

def pascal_objc(s):
    """Convert pascal_case -> PascalCase

    Objective C uses pascal case, but there are e exceptions that it uppercases
    the entire segment: url, http, and https.

    https://github.com/protocolbuffers/protobuf/blob/54176b26a9be6c9903b375596b778f51f5947921/src/google/protobuf/compiler/objectivec/objectivec_helpers.cc#L91

    Args:
      s (string): The input string to be capitalized.

    Returns: (string): The capitalized string.
    """
    segments = []
    for segment in s.split("_"):
        repl = _objc_upper_segments.get(segment)
        if repl:
            segment = repl
        else:
            segment = capitalize(segment)
        segments.append(segment)
    return "".join(segments)

def pascal_case(s):
    """Convert pascal_case -> PascalCase

    Args:
        s (string): The input string to be capitalized.

    Returns:
        (string): The capitalized string.
    """
    return "".join([capitalize(part) for part in s.split("_")])

def rust_keyword(s):
    """Check if arg is a rust keyword and append '_pb' if true.

    Args:
        s (string): The input string to be capitalized.

    Returns:
        (string): The appended string.
    """
    return s + "_pb" if s in _rust_keywords else s

def python_path(s):
    """Convert a path string to a python import compatible path as is generated
    by the python plugin. Python import paths cannot contain dashes, so these
    are replaced by underscores.
    See https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/compiler/python/python_generator.cc#L89-L95

    Args:
        s (string): The input string to be converted.

    Returns:
        (string): The converted string.
    """
    return s.replace("-", "_")

def php_path(s):
    """Convert a path string to a php path as is generated by the php plugin.

    Args:
        s (string): The input string to be converted.

    Returns:
        (string): The converted string.
    """
    return "/".join([capitalize(c) for c in s.split("/")])

def get_int_attr(attr, name):
    value = getattr(attr, name)
    if value == "":
        return 0
    if value == "None":
        return 0
    return int(value)

def get_bool_attr(attr, name):
    value = getattr(attr, name)
    if value == "True":
        return True
    if value == "False":
        return False
    fail("Invalid bool value: %s" % value)

def get_output_filename(src_file, pattern, proto_info, package_path = ""):
    """Build the predicted filename for file generated by the given plugin.

    A 'proto_plugin' rule allows one to define the predicted outputs.  For
    flexibility, we allow special tokens in the output filename that get
    replaced here. The overall pattern is '{token}' mimicking the python
    'format' feature.

    Additionally, there are '|' characters like '{basename|pascal}' that can be
    read as 'take the basename and pipe that through the pascal function'.

    Args:
      src_file: the .proto <File>
      pattern: the input pattern string
      package_path: an optional string such that for a file "bar.txt" with 
            protopath "foo" and package_path "x", the final output 
            path is x/bar.txt.
      proto_info: The <ProtoInfo> object

    Returns:
      the replaced string
    """

    # any pattern having the prefix './' is not modified
    if pattern.startswith("./"):
        return pattern[2:]

    # Get proto path and strip extension
    protopath = descriptor_proto_path(src_file, proto_info)

    if protopath.endswith(".proto"):
        protopath = protopath[:-6]
    elif protopath.endswith(".protodevel"):
        protopath = protopath[:-11]
    protopath_partitions = protopath.rpartition("/")

    # Get output basename and strip extension
    basename = src_file.basename
    if basename.endswith(".proto"):
        basename = basename[:-6]
    elif basename.endswith(".protodevel"):
        basename = basename[:-11]

    # Replace tokens
    filename = ""
    if "{basename}" in pattern:
        filename = pattern.replace("{basename}", basename)
    elif "{protopath}" in pattern:
        filename = pattern.replace("{protopath}", protopath)
    elif "{basename|pascal}" in pattern:
        filename = pattern.replace("{basename|pascal}", pascal_case(basename))
    elif "{protopath|pascal}" in pattern:
        filename = pattern.replace("{protopath|pascal}", "/".join([
            # Pascal case only the file name
            protopath_partitions[0],
            pascal_case(protopath_partitions[2]),
        ]))
    elif "{basename|python}" in pattern:
        filename = pattern.replace("{basename|python}", python_path(basename))
    elif "{protopath|python}" in pattern:
        filename = pattern.replace("{protopath|python}", python_path(protopath))
    elif "{basename|php}" in pattern:
        filename = pattern.replace("{basename|php}", php_path(basename))
    elif "{protopath|php}" in pattern:
        filename = pattern.replace("{protopath|php}", php_path(protopath))
    elif "{basename|pascal|objc}" in pattern:
        filename = pattern.replace("{basename|pascal|objc}", pascal_objc(basename))
    elif "{protopath|pascal|objc}" in pattern:
        filename = pattern.replace("{protopath|pascal|objc}", "/".join([
            # Pascal case only the file name
            protopath_partitions[0],
            pascal_objc(protopath_partitions[2]),
        ]))
    elif "{basename|rust_keyword}" in pattern:
        filename = pattern.replace("{basename|rust_keyword}", rust_keyword(basename))
    elif "{protopath|rust_keyword}" in pattern:
        filename = pattern.replace("{basename|rust_keyword}", rust_keyword(protopath))
    else:
        filename += basename + pattern

    if package_path:
        parts = filename.rpartition("/")
        basename = parts[2]
        filename = "/".join([package_path, basename])

    return filename

def copy_file(actions, src_file, dest_path, sibling = None):
    """Copy a file to a new path destination

    Args:
      actions: the <ctx.actions> object
      src_file: the source file <File>
      dest_path: the destination path of the file
      sibling: a file to use as a sibling to declare_file <File>

    Returns:
      <Generated File> for the copied file
    """
    dest_file = actions.declare_file(dest_path, sibling = sibling)
    actions.run_shell(
        mnemonic = "CopyFile",
        inputs = [src_file],
        outputs = [dest_file],
        command = "cp '{}' '{}'".format(src_file.path, dest_file.path),
        progress_message = "copying file {} to {}".format(src_file.path, dest_file.path),
    )
    return dest_file

def descriptor_proto_path(proto, proto_info):
    """Convert a proto File to the path within the descriptor file.

    Adapted from https://github.com/bazelbuild/rules_go
    """

    # Strip proto_source_root
    path = strip_path_prefix(proto.path, proto_info.proto_source_root)

    # Strip root
    path = strip_path_prefix(path, proto.root.path)

    # Strip workspace root
    path = strip_path_prefix(path, proto.owner.workspace_root)

    return path

def strip_path_prefix(path, prefix):
    """Strip a prefix from a path if it exists and any remaining prefix slashes

    Args:
        path: <string>
        prefix: <string>
    Returns:
        <string>
    """
    if path.startswith(prefix):
        path = path[len(prefix):]
    if path.startswith("/"):
        path = path[1:]
    return path

def parse_version(version_str):
    """
    Parse the bazel version string, returning a tuple

    Derived from https://github.com/tensorflow/tensorflow/blob/master/tensorflow/version_check.bzl
    """

    # Extract just the semver part
    semver_str = version_str.partition(" ")[0].partition("-")[0]

    # Return version tuple
    return tuple([n for n in semver_str.split(".")])

# Check that a specific bazel version is being used.
def check_bazel_minimum_version(minimum_bazel_version):
    """
    Check that the bazel version meets or exceeds the required version

    Derived from https://github.com/tensorflow/tensorflow/blob/master/tensorflow/version_check.bzl

    Args:
        minimum_bazel_version: <string>
    """

    # Check for bazel versions that did not support version checking
    if "bazel_version" not in dir(native):
        fail("Bazel version is lower than 0.2.1, rules_proto_grpc requires at least {}".format(minimum_bazel_version))

    # Check for non-release versions
    if not native.bazel_version:
        print("Bazel is not a release version, rules_proto_grpc requires at least {}".format(minimum_bazel_version))
        return

    # Check version strings
    current_version_tuple = parse_version(native.bazel_version)
    minimum_version_tuple = parse_version(minimum_bazel_version)
    if current_version_tuple < minimum_version_tuple:
        fail(
            "Bazel version is {}, rules_proto_grpc requires at least {}".format(
                native.bazel_version,
                minimum_bazel_version,
            ),
        )

def uniq(iterable):
    """Returns a list of unique elements in `iterable`.

    Requires all the elements to be hashable.
    Args:
      iterable: An iterable to filter.
    Returns:
      A new list with all unique elements from `iterable`.
    """
    unique_elements = {element: None for element in iterable}

    # list() used here for python3 compatibility.
    # TODO(bazel-team): Remove when testing frameworks no longer require python compatibility.
    return list(unique_elements.keys())

def homogenize(desc, items):
    """Returns a single value from itemss, asserting the values are all the same.

    Args:
      desc: An description of the thing that is being filtered (for error message)
      items: An iterable to filter.
    Returns:
      The first value. Fails if any subsequent values do not match the first
    """
    value = None
    for item in items:
        if not value:
            value = item
        if item != value:
            fail(desc + ": must all have the same value: got %r" % items)
    return value

def flatten(list_of_lists):
    result = []
    for items in list_of_lists:
        result.extend(items)
    return result

def is_string(v):
    """Returns True if v is an instance of a string.

    Args:
      v: The value whose type should be checked.
    Returns:
      True if v is an instance of a string, False otherwise.
    """
    return type(v) == type("")

def get_protoc_executable(ctx):
    protoc_toolchain_info = ctx.toolchains[str(Label("//toolchains:protoc_toolchain_type"))]
    return protoc_toolchain_info.protoc_executable
