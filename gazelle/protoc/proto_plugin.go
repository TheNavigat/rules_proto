package protoc

// ProtoPlugin implementations are capable of predicting the sources that are
// generated by a particular protoc plugin.
type ProtoPlugin interface {
	// // Label returns the unique name for the plugin
	// Label() label.Label

	// ShouldApply asks the plugin: for the given proto_library rule, should you
	// be added to the list of plugins to use?  We cannot rely on GeneratedSrcs
	// alone for this information as not all plugins actually generate source
	// code (some only perform validation/checking).
	ShouldApply(rel string, cfg *ProtoPackageConfig, lib ProtoLibrary) bool

	// GeneratedSrcs inspects the given proto_library and determines what source
	// files will be generated.  Each element in the list should be a
	// fully-qualified path relative to the plugin out.
	GeneratedSrcs(rel string, cfg *ProtoPackageConfig, lib ProtoLibrary) []string
}

// PluginOptionsProvider is an optional interface that, if implemented, provides
// additional options for the protoc invocation.
type PluginOptionsProvider interface {
	// GeneratedOptions inspects the given proto_library and determines what
	// additional options are needed.
	GeneratedOptions(rel string, c *ProtoPackageConfig, lib ProtoLibrary) []string
}

// PluginMappingsProvider is an optional interface that, if implemented,
// provides mapping data for the protoc invocation.
type PluginMappingsProvider interface {
	// GeneratedOptions inspects the given proto_library and determines what
	// additional mappings are needed.
	GeneratedMappings(rel string, c *ProtoPackageConfig, lib ProtoLibrary) map[string]string
}

// PluginOutProvider is an optional interface that, if implemented, provides the
// plugin-specific value for the --*_out= arg.
type PluginOutProvider interface {
	// GeneratedOut inspects the given proto_library and determines the out
	// arg.
	GeneratedOut(rel string, c *ProtoPackageConfig, lib ProtoLibrary) string
}
