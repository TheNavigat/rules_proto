package protoc

import (
	"fmt"
	"path"
	"sort"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/rule"
	"github.com/bazelbuild/buildtools/build"
)

// ProtoCompileRule implements a ruleProvider for the @build_stack_rules_proto
// family of rules.  These all share a similar pattern but differ on naming
// based on the target language, whether or not it's a proto (only messages) or
// gRPC (has_services), and whether it's the "_compile" rule (which generates
// the sources) or the language-wrapped "_library" rule.
type ProtoCompileRule struct {
	// the workspace relative path of the BUILD file where this rule is being
	// generated.
	rel string
	// the prefix for the rule (e.g. 'java')
	prefix string
	// the library thar holds the proto filees
	library ProtoLibrary
	// the list of plugins to applied for the protoc invocation
	plugins []label.Label
	// a mapping from plugin name -> file mappings that are generated by that
	// plugin.  Each element in the list is expected to be a filename that is
	// fully-qualified relative to the plugin_out.  If the package rel dir is
	// not a prefix of B, this implies that the initial output file generated by
	// protoc will violate the bazel invariant that states all output files must
	// be relative to the package.  In this case we need to copy B -> A as a
	// separate action to produce the desired output.
	gensrcs map[string][]string
	// a mapping from plugin name -> list of additional options for the plugin
	options map[string][]string
	// a mapping from plugin name -> list of mappings for plugin
	mappings map[string]map[string]string
	// a mapping from plugin name -> output location for the plugin invocation
	outs       map[string]string
	visibility []string
	comment    []string
}

// NewProtoCompileRule constructs a new ProtoCompileRule based on the proto_library on which
// it depends, as well as the precomputed list of genfiles.
func NewProtoCompileRule(
	rel string,
	prefix string,
	library ProtoLibrary,
	plugins []label.Label,
	gensrcs map[string][]string,
	options map[string][]string,
	mappings map[string]map[string]string,
	outs map[string]string,
) *ProtoCompileRule {
	rule := &ProtoCompileRule{
		rel:      rel,
		prefix:   prefix,
		library:  library,
		plugins:  plugins,
		gensrcs:  gensrcs,
		options:  options,
		mappings: mappings,
		outs:     outs,
	}
	return rule
}

// Kind implements part of the ruleProvider interface.
func (s *ProtoCompileRule) Kind() string {
	return fmt.Sprintf("proto_compile")
}

// Name implements part of the ruleProvider interface.
func (s *ProtoCompileRule) Name() string {
	return fmt.Sprintf("%s_%s_compile", s.library.BaseName(), s.prefix)
}

// Imports implements part of the ruleProvider interface.
func (s *ProtoCompileRule) Imports() []string {
	return []string{s.Kind()}
}

// Visibility implements part of the ruleProvider interface.
func (s *ProtoCompileRule) Visibility() []string {
	return s.visibility
}

// Rule implements part of the ruleProvider interface.
func (s *ProtoCompileRule) Rule() *rule.Rule {
	newRule := rule.NewRule(s.Kind(), s.Name())
	visibility := s.Visibility()
	if len(s.visibility) > 0 {
		newRule.SetAttr("visibility", visibility)
	}
	if s.comment != nil {
		for _, line := range s.comment {
			newRule.AddComment(line)
		}
	}

	genfiles, mappings := s.genfiles()
	newRule.SetAttr("genfiles", genfiles)
	newRule.SetAttr("plugins", s.pluginLabels())
	newRule.SetAttr("proto", s.library.Name())
	if len(mappings) > 0 {
		newRule.SetAttr("mappings", makeStringDict(mappings))
	}
	if len(s.options) > 0 {
		newRule.SetAttr("options", makeStringListDict(s.options))
	}
	if len(s.outs) > 0 {
		newRule.SetAttr("outs", makeStringDict(s.outs))
	}

	return newRule
}

// KindInfo implements part of the ruleProvider interface.
func (s *ProtoCompileRule) KindInfo() rule.KindInfo {
	return rule.KindInfo{
		NonEmptyAttrs:  map[string]bool{"deps": true},
		MergeableAttrs: map[string]bool{},
	}
}

// Deps computes the dependencies of the rule.
func (s *ProtoCompileRule) Deps() []string {
	return []string{":" + s.library.Name()}
}

// pluginLabels returns the label strings for the plugins.
func (s *ProtoCompileRule) pluginLabels() []string {
	labels := make([]string, len(s.plugins))
	for i, lab := range s.plugins {
		labels[i] = lab.String()
	}
	return labels
}

// genfiles computes the source files that are generated by the rule.
func (s *ProtoCompileRule) genfiles() (srcs []string, mappings map[string]string) {
	mappings = make(map[string]string)

	for plugin, files := range s.gensrcs {
		// if plugin provided mappings for us, use those preferentially
		pluginMappings := s.mappings[plugin]
		if len(pluginMappings) > 0 {
			for k, v := range pluginMappings {
				mappings[k] = v
			}
			continue
		}
		// otherwise, fallback to baseline method
		for _, file := range files {
			dir := path.Dir(file)
			base := path.Base(file)
			if dir == s.rel {
				// no mapping required, just add to the srcs list
				srcs = append(srcs, strings.TrimPrefix(file, s.rel+"/"))
			} else {
				// add the basename only to the srcs list and add a mapping.
				srcs = append(srcs, base)
				mappings[base] = file
			}
		}
	}

	return
}

// Resolve implements part of the RuleProvider interface.
func (s *ProtoCompileRule) Resolve(c *config.Config, r *rule.Rule, importsRaw interface{}, from label.Label) {
}

func makeStringListDict(in map[string][]string) build.Expr {
	items := make([]*build.KeyValueExpr, 0)
	keys := make([]string, 0)
	for k := range in {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, key := range keys {
		values := in[key]
		sort.Strings(values)
		value := &build.ListExpr{List: make([]build.Expr, len(values))}
		for i, val := range values {
			value.List[i] = &build.StringExpr{Value: val}
		}
		items = append(items, &build.KeyValueExpr{
			Key:   &build.StringExpr{Value: key},
			Value: value,
		})
	}
	return &build.DictExpr{List: items}
}

func makeStringDict(in map[string]string) build.Expr {
	dict := &build.DictExpr{}
	keys := make([]string, 0)
	for k := range in {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	for _, key := range keys {
		value := in[key]
		dict.List = append(dict.List, &build.KeyValueExpr{
			Key:   &build.StringExpr{Value: key},
			Value: &build.StringExpr{Value: value},
		})
	}
	return dict
}
