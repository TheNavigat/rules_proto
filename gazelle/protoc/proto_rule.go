package protoc

import (
	"fmt"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

// ProtoRule implements a ruleProvider for the @build_stack_rules_proto family
// of rules.  These all share a similar pattern but differ on naming based on
// the target language, whether or not it's a proto (only messages) or gRPC
// (has_services), and whether it's the "_compile" rule (which generates the
// sources) or the language-wrapped "_library" rule.
type ProtoRule struct {
	library    ProtoLibrary
	lang       string // 'py'
	kind       string // 'proto' or 'grpc'
	cls        string // 'library' or 'compile'
	visibility []string
	comment    []string
}

// NewProtoRule constructs a new ProtoRule based on the proto_library on which
// it depends, as well as the naming metadata.
func NewProtoRule(library ProtoLibrary, lang, kind, cls string, options ...ProtoRuleOption) *ProtoRule {
	rule := &ProtoRule{
		library: library,
		lang:    lang,
		kind:    kind,
		cls:     cls,
	}
	for _, option := range options {
		rule = option(rule)
	}
	return rule
}

// Kind implements part of the ruleProvider interface.
func (s *ProtoRule) Kind() string {
	return fmt.Sprintf("%s_%s_%s", s.lang, s.kind, s.cls)
}

// Name implements part of the ruleProvider interface.
func (s *ProtoRule) Name() string {
	return fmt.Sprintf("%s_%s_%s_%s", s.library.BaseName(), s.lang, s.kind, s.cls)
}

// Imports implements part of the ruleProvider interface.
func (s *ProtoRule) Imports() []string {
	return []string{s.Kind()}
}

// Visibility implements part of the ruleProvider interface.
func (s *ProtoRule) Visibility() []string {
	return []string{"//visibility:public"}
}

// Rule implements part of the ruleProvider interface.
func (s *ProtoRule) Rule() *rule.Rule {
	newRule := rule.NewRule(s.Kind(), s.Name())
	newRule.SetAttr("deps", s.Deps())
	if s.visibility != nil {
		newRule.SetAttr("visibility", s.Visibility())
	}
	if s.comment != nil {
		for _, line := range s.comment {
			newRule.AddComment(line)
		}
	}

	// special case for go_package option.  TODO: refactor this to make a
	// subclass like go_proto_rule that does this.
	if strings.HasPrefix(s.lang, "go") {
		for _, file := range s.library.Files() {
			pkg, _, ok := getGoPackageOption(file.GetOptions())
			if ok {
				newRule.SetAttr("go_package", pkg)
				break
			}
		}
	}
	return newRule
}

// KindInfo implements part of the ruleProvider interface.
func (s *ProtoRule) KindInfo() rule.KindInfo {
	return rule.KindInfo{
		NonEmptyAttrs:  map[string]bool{"deps": true},
		MergeableAttrs: map[string]bool{},
	}
}

// Deps computes the dependencies of the rule.
func (s *ProtoRule) Deps() []string {
	return []string{":" + s.library.Name()}
}

// GeneratedSrcs computes the source files that are generated by the rule.  The
// implementation currently hardcodes the information that is encapsulated by
// the @build_stack_rules_proto "proto_plugin" provider.
func (s *ProtoRule) GeneratedSrcs() []string {
	srcs := make([]string, 0)
	for _, file := range s.library.Files() {
		basename := file.Name
		switch s.lang {
		case "go", "gogo", "gogofast", "gogofaster":
			srcs = append(srcs, basename+".pb.go")
		case "py":
			switch s.kind {
			case "proto":
				srcs = append(srcs, basename+"_pb2.py")
			case "grpc":
				srcs = append(srcs, basename+"_pb2_grpc.py")
			}
		case "py_abc":
			srcs = append(srcs, pyAbcGeneratedSrc(basename))
		case "py_enum_choices":
			srcs = append(srcs, pyEnumChoicesGeneratedSrc(basename))
		case "py_rstubs":
			srcs = append(srcs, pyRstubsGeneratedSrc(basename))
		}
	}
	return srcs
}

// Resolve implements part of the RuleProvider interface.
func (s *ProtoRule) Resolve(c *config.Config, r *rule.Rule, importsRaw interface{}, from label.Label) {
}

func pyAbcGeneratedSrc(basename string) string {
	return basename + "_abc.py"
}

func pyEnumChoicesGeneratedSrc(basename string) string {
	return basename + "_choices.py"
}

func pyRstubsGeneratedSrc(basename string) string {
	return basename + ".py"
}
